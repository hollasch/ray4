//**************************************************************************************************
//  Copyright (c) 1991-2024 Steven R Hollasch
//
//  MIT License
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//  and associated documentation files (the "Software"), to deal in the Software without
//  restriction, including without limitation the rights to use, copy, modify, merge, publish,
//  distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
//  Software is furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all copies or
//  substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//  BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//**************************************************************************************************

//==================================================================================================
// image4
//
// This tool manipulates 3D image cubes generated by the `ray4` 4D raytracer.
//==================================================================================================

#include "r4_image.h"

#include <fstream>
#include <iostream>
#include <string>
#include <vector>

using namespace std;
using ImageHeader = ImageHeader_1;


//__________________________________________________________________________________________________
// Information Text Definitions

static auto version = L"image4 0.0.1 | 2024-11-03 | https://github.com/hollasch/ray4/tree/master/image4\n";

static auto usage = LR"(
image4: 3D image manipulation tool for ray4 ray tracer
usage:  image4 [-h|--help] [-v|--version]
               <-i|--image|--input <imageFile>>
               [-q|--query]
               [-o|--output <outputImageFile>]
               [-s|--slice <start>[-<end>][x<stepSize>]]
               [-t|--tiled <pixelWidth>[x<horizontalCount>]]

This tool reads a 3D image cube produced by the ray4 4D ray tracer, and either
reports information about the file, or generates one or more images from that
image cube, depending on the command line options.

-h, --help
    Print usage + version information and exit.

-v, --version
    Print version information and exit.

-i, --input <imageFile>, --image <imageFile>
    Required argument unless the help option is given. The input image file is
    produced by the `ray4` 4D ray tracer, either the original image cube format,
    or the newer (2024 and after) format.

-q, --query
    If provided, print information about the image cube file instead of
    generating output images.

-o, --output <outputImageFile>
    Required to produce one or more output image files. This file will be
    overwritten if it already exists. The output image file may contain the
    substring `##` (exactly two consecutive hash characters), which will be
    replaced with the slice index. If the output file name does not contain this
    substring, the slice index will be appended to the end if more than one
    slice is requested.

-s, --slice <start>[-<end>][x<stepSize>]
    Optional. If unspecified, all slices will be generated. If one number is
    given, then that slice will be output. If a range is specified (such as
    '--start 5-10'), then all slices in that range will be generated. A step
    size may be included by appending an 'x' and a number. This works for whole
    range ('--slice x5'), offset to end of cube ('--slice 20x5'), and stepped
    range ('--slice 20-80x10').

-t, --tiled <pixelWidth>[x<horizontalCount>]
    Generates a contact sheet of thumbnail images. If only a pixel width is
    specified, then the output image will be that many pixels wide, and slices
    will be sized to match the X:Y aspect ratio of the image cube. For example,
    with an image cube that is 200x100x50, and given a tiled target of 2000
    pixels horizontally, the generated contact sheet will have 64 tiles, 8
    thumbnails wide by 7 thumbnails, with the bottom row only having two
    thumbnails. In other words, given N slices, the target is a sqrt(N) x
    sqrt(N) grid.
        If a horizontalCount is specified, then each row will have the specified
    number of thumbnails, sized to fit, with as tall a result as needed to
    display all slices.

)";

//__________________________________________________________________________________________________
// Program Parameters

struct Parameters {
    bool    printHelp{false};         // Print help + version information and exit.
    bool    printVersion{false};      // Print version information and exit.
    wstring imageFileName;            // Input image cube file name
    bool    printFileInfo{false};     // Print information about the image cube file.
    wstring outputFileName;           // Output image file name
    int     sliceStart{0};            // First slice to output
    int     sliceEnd{-1};             // Last output slice. -1 indicates last slice
    int     sliceStep{1};             // Step size between slices
    bool    showTiled{false};         // Generate a tiled contact sheet of thumbnails.
    int     tiledPixelWidth{0};       // Width in pixels of tiled contact sheet
    int     tiledHorizontalCount{0};  // Number of thumbnails per row in tiled contact sheet
};

enum class OptionType {
    Help,
    Version,
    ImageFileName,
    Query,
    OutputFileName,
    Slice,
    Tiled,
    Unrecognized
};

struct OptionInfo {
    // A description of a single command-line option.

    OptionType type;
    wchar_t    singleLetter;  // Single dash letter
    wstring    longName;      // Double dash string
    bool       takesValue;    // If true, takes option value
};

static vector<OptionInfo> optionInfo = {
    {OptionType::Unrecognized,   0,    L"",        false},
    {OptionType::Help,           L'h', L"help",    false},
    {OptionType::Version,        L'v', L"version", false},
    {OptionType::ImageFileName,  L'i', L"input",   true},
    {OptionType::ImageFileName,  L'i', L"image",   true},
    {OptionType::Query,          L'q', L"query",   false},
    {OptionType::OutputFileName, L'o', L"output",  true},
    {OptionType::Slice,          L's', L"slice",   true},
    {OptionType::Tiled,          L't', L"tiled",   true},
};

//__________________________________________________________________________________________________

const OptionInfo& getOptionInfo(wchar_t *arg) {
    // Given a command-line option, return the corresponding OptionInfo structure.

    if (arg[0] == L'/' && arg[1] == L'?')
        return optionInfo[1];

    if (arg[0] != L'-')
        return optionInfo[0];

    if (arg[1] == L'-') {
        for (const auto& option : optionInfo)
            if (_wcsicmp(option.longName.c_str(), arg + 2) == 0)
                return option;
    }

    for (const auto& option : optionInfo)
        if (option.singleLetter == arg[1])
            return option;

    return optionInfo[0];
}

//__________________________________________________________________________________________________

std::pair<wchar_t*, int> readInteger (wchar_t* str) {
    // Reads the integer from the string. Returns a pair containing the pointer to the remainder of
    // the string, and the integer value.

    auto *ptr = str;
    bool negate = *ptr == L'-';
    if (negate) ++ptr;

    int value = 0;
    for (; isdigit(*ptr);  ++ptr)
        value = (10 * value) + (*ptr - L'0');

    return { ptr, negate ? -value : value };
}

//__________________________________________________________________________________________________

bool parseOptionValueSlice (Parameters &params, wchar_t* value) {
    // Parse the --slice option string. Format is '<start>[-<end>][x<stepSize>]'.

    const auto optionValue = value;

    if (!isdigit(*value)) {
        wcerr << "image4: Invalid slice start (" << optionValue << ").\n";
        return false;
    }

    std::tie(value, params.sliceStart) = readInteger(value);

    if (*value == '-') {
        ++value;
        if (!isdigit(*value)) {
            wcerr << "image4: Invalid slice end (" << optionValue << ").\n";
            return false;
        }
        std::tie(value, params.sliceEnd) = readInteger(value);
    }

    if (*value == 'x') {
        ++value;
        if (!isdigit(*value)) {
            wcerr << "image4: Invalid slice step (" << optionValue << ").\n";
            return false;
        }
        std::tie(value, params.sliceStep) = readInteger(value);
    }

    if (*value) {
        wcerr << "image4: Invalid slice option value (" << optionValue << ").\n";
        return false;
    }

    return true;
}

//__________________________________________________________________________________________________

bool parseOptionValueTiled (Parameters &params, wchar_t* value) {
    // Parse the --tiled option string. Format is '<pixelWidth>[x<horizontalCount]'.

    const auto optionValue = value;

    if (!isdigit(*value)) {
        wcerr << "image4: Invalid tiled pixel width (" << optionValue << ").\n";
        return false;
    }

    std::tie(value, params.tiledPixelWidth) = readInteger(value);

    if (*value == 'x') {
        ++value;
        if (!isdigit(*value)) {
            wcerr << "image4: Invalid tiled horizontal count (" << optionValue << ").\n";
            return false;
        }
        std::tie(value, params.tiledHorizontalCount) = readInteger(value);
    }

    if (*value) {
        wcerr << "image4: Invalid tiled option value (" << optionValue << ").\n";
        return false;
    }

    return true;
}

//__________________________________________________________________________________________________

bool processParameters (Parameters &params, int argc, wchar_t *argv[]) {
    // Process the command-line options and load results into the given Parameters object. Returns
    // true on success, false on error.

    for (auto argi = 1;  argi < argc;  ++argi) {
        auto *arg = argv[argi];
        auto optionInfo = getOptionInfo(arg);
        wchar_t *optionValue = nullptr;

        if (optionInfo.takesValue) {
            if (arg[1] != '-' && arg[2] != 0) {  // Single letter option joined with argument value.
                optionValue = arg + 2;
            } else {
                // Option value is next argument.
                if ((argi + 1) == argc) {
                    wcerr << "image4: Missing argument for (" << arg << ").\n";
                    return false;
                }
                optionValue = argv[++argi];
            }
        }

        if (optionInfo.type == OptionType::Unrecognized) {
            wcerr << "image4: Unrecognized command argument: (" << arg << ").\n";
            return false;
        }

        switch (optionInfo.type) {
            default:
            case OptionType::Unrecognized:
                wcerr << "image4: Unrecognized command argument: (" << arg << ").\n";
                return false;

            case OptionType::Help:
                params.printHelp = true;
                break;

            case OptionType::Version:
                params.printVersion = true;
                break;

            case OptionType::ImageFileName:
                params.imageFileName = optionValue;
                break;

            case OptionType::Query:
                params.printFileInfo = true;
                break;

            case OptionType::OutputFileName:
                params.outputFileName = optionValue;
                break;

            case OptionType::Slice:
                if (!parseOptionValueSlice(params, optionValue))
                    return false;
                break;

            case OptionType::Tiled:
                if (!parseOptionValueTiled(params, optionValue))
                    return false;
                break;
        }
    }

    wcout << "\nCommand-line parameters:\n";
    wcout << "    printHelp: " << (params.printHelp ? "true\n" : "false\n");
    wcout << "    imageFileName: '" << params.imageFileName << "'\n";
    wcout << "    printFileInfo: " << (params.printFileInfo ? "true\n" : "false\n");
    wcout << "    outputFileName: '" << params.outputFileName << "'\n";
    wcout << "    slice: " << params.sliceStart << " - " << params.sliceEnd << " x " << params.sliceStep << '\n';
    wcout << "    showTiled: " << (params.showTiled ? "true\n" : "false\n");
    wcout << "    tiledPixelWidth: " << params.tiledPixelWidth << '\n';
    wcout << "    tiledHorizontalCount: " << params.tiledHorizontalCount << '\n';

    return true;
}

//__________________________________________________________________________________________________

ifstream openImageFile(const wstring& fileName) {
    // Opens the input image file for reading.

    ifstream imageFile;
    imageFile.open(fileName, ios::binary | ios::in);
    return imageFile;
}

//__________________________________________________________________________________________________

uint32_t readUInt32(ifstream &is) {
    char b[4];
    is.read(b, sizeof(b));
    return (b[0] << 24) | (b[1] << 16) | (b[2] << 8) | b[3];
}

//__________________________________________________________________________________________________

uint16_t readUInt16(ifstream &is) {
    char b[2];
    is.read(b, sizeof(b));
    return (b[0] << 8) | b[1];
}

//__________________________________________________________________________________________________

uint8_t readUInt8(ifstream &is) {
    char b;
    is.read(&b, 1);
    return static_cast<uint8_t>(b);
}

//__________________________________________________________________________________________________

ImageHeader readImageHeader(ifstream &imageFile, wstring imageFileName) {
    // Reads in and returns the 3D image cube header structure. On failure, the magic field is set
    // to zero.

    ImageHeader header;

    header.magic = readUInt32(imageFile);
    if (header.magic != ray4FormatMagic) {
        wcerr << "image4: Image file \"" << imageFileName << "\" is not a value ray4 image file.\n";
        return { 0 };
    }

    header.version = readUInt8(imageFile);
    if (header.version != 1) {
        wcerr << "image4: ray4 image file \"" << imageFileName << "\" is an unsupported version ("
              << header.version << ").\n";
        return { 0 };
    }

    header.bitsPerPixel = readUInt8(imageFile);
    if (header.bitsPerPixel != 24) {
        wcerr << "image4: ray4 image file \"" << imageFileName << "\" has an unsupported bits per pixel ("
            << header.bitsPerPixel << ").\n";
        return { 0 };
    }

    for (auto i = 0;  i < 3;  ++i)
        header.aspect[i] = readUInt16(imageFile);

    if (header.aspect[0] != 1 || header.aspect[1] != 1 || header.aspect[2] != 1) {
        wcerr << "image4: ray4 image file \"" << imageFileName << "\" has aspect ratio "
              << header.aspect[0] << ':' << header.aspect[1] << ':' << header.aspect[2]
              << ". Only 1:1:1 is supported.\n";
        return { 0 };
    }

    for (auto i = 0;  i < 3;  ++i)
        header.start[i] = readUInt16(imageFile);

    for (auto i = 0;  i < 3;  ++i)
        header.end[i] = readUInt16(imageFile);

    if (header.end[0] < header.start[0] || header.end[1] < header.start[1] || header.end[2] < header.start[2]) {
        wcerr << "image4: ray4 image file \"" << imageFileName << "\" has invalid start/end values.\n";
        return { 0 };
    }

    wcout << "\nImage Header:\n";
    wcout << "    Magic: 0x" << std::hex << header.magic << '\n' << std::dec;
    wcout << "    Version: " << header.version << '\n';
    wcout << "    Bits Per Pixel: " << header.bitsPerPixel << '\n';

    wcout << "    aspect: "
          << header.aspect[0] << ','
          << header.aspect[1] << ','
          << header.aspect[2] << '\n';

    wcout << "    start: "
          << header.start[0] << ','
          << header.start[1] << ','
          << header.start[2] << '\n';

    wcout << "    end: "
          << header.end[0] << ','
          << header.end[1] << ','
          << header.end[2] << '\n';

    return header;
}

//__________________________________________________________________________________________________

int wmain(int argc, wchar_t *argv[]) {
    Parameters params;

    if (!processParameters(params, argc, argv))
        return 1;

    if (params.printHelp)
        wcout << usage;

    if (params.printHelp || params.printVersion) {
        wcout << version;
        return 0;
    }

    if (params.imageFileName.empty()) {
        wcerr << "image4: Missing input image file name.\n";
        return 1;
    }

    ifstream imageStream = openImageFile(params.imageFileName);

    if (!imageStream.good()) {
        wcerr << "image4: Open failed for image file \"" << params.imageFileName << "\".\n";
        return 1;
    }

    ImageHeader imageHeader = readImageHeader(imageStream, params.imageFileName);

    if (!imageHeader.magic)
        return 1;

    return 0;
}
