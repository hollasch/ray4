//**************************************************************************************************
//  Copyright (c) 1991-2024 Steven R Hollasch
//
//  MIT License
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy of this software
//  and associated documentation files (the "Software"), to deal in the Software without
//  restriction, including without limitation the rights to use, copy, modify, merge, publish,
//  distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
//  Software is furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in all copies or
//  substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
//  BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
//  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//**************************************************************************************************

//==================================================================================================
// image4
//
// This tool manipulates 3D image cubes generated by the `ray4` 4D raytracer.
//==================================================================================================

#include "r4_image.h"

#include <fstream>
#include <iomanip>
#include <iostream>
#include <string>
#include <vector>

using namespace std;
using ImageHeader = ImageHeader_1;


//__________________________________________________________________________________________________
// Information Text Definitions

static auto version = L"image4 0.0.1 | 2024-11-03 | https://github.com/hollasch/ray4/tree/master/image4\n";

static auto usage = LR"(
image4: 3D image manipulation tool for ray4 ray tracer
usage:  image4 [-h|--help] [-v|--version]
               <-i|--image|--input <imageFile>>
               [-q|--query]
               [-o|--output <outputImageFile>]
               [-s|--slice <start>[-<end>][x<stepSize>]]

This tool reads a 3D image cube produced by the ray4 4D ray tracer, and either
reports information about the file, or generates one or more images from that
image cube, depending on the command line options.

-h, --help
    Print usage + version information and exit.

-v, --version
    Print version information and exit.

-i, --input <imageFile>, --image <imageFile>
    Required argument unless the help option is given. The input image file is
    produced by the `ray4` 4D ray tracer, either the original image cube format,
    or the newer (2024 and after) format.

-q, --query
    Required if --output is not provided. If provided, print information about
    the image cube file instead of generating output images.

-o, --output <outputImageFile>
    Required if --query is not provided. If provided, generate one or more
    output image files with the specified name. This file will be overwritten
    if it already exists. The output image file may contain the substring `##`
    (exactly two consecutive hash characters), which will be replaced with the
    slice index, with leading zeros so that all output file names have the same
    length. If the output file name does not contain this substring, the slice
    index will be appended to the end if more than one slice is requested.

-f, --format <Output Image File Format>
    The default output image file format is binary PPM. Supported explicit
    formats are:

        ppm        -- Binary PPM
        ppm/ascii  -- ASCII PPM
        ppm/binary -- Binary PPM

    If the output filename has a file extension, then ".ppm" yields a binary
    PPM formatted file. All other extensions will yield an error.

-s, --slice <start>[-<end>][x<stepSize>]
    Optional. If unspecified, all slices will be generated. If one number is
    given, then that slice will be output. If a range is specified (such as
    '--start 5-10'), then all slices in that range will be generated. A step
    size may be included by appending an 'x' and a number. This works for whole
    range ('--slice x5'), offset to end of cube ('--slice 20x5'), and stepped
    range ('--slice 20-80x10').

)";

//__________________________________________________________________________________________________
// Output File Formats

enum class FileFormat {
    PPM_ASCII,
    PPM_Binary,
    None
};

struct FormatInfo {
    FileFormat format;
    wstring    name;
    wstring    fileExtension;
};

namespace {
    FormatInfo formatInfo[] = {
        { FileFormat::PPM_Binary, L"ppm",        L".ppm" },
        { FileFormat::PPM_Binary, L"ppm:binary", L".ppm" },
        { FileFormat::PPM_ASCII,  L"ppm:ascii",  L".ppm" },
        { FileFormat::None,       L"",           L""     },
    };
};

//__________________________________________________________________________________________________
// Program Parameters

struct Parameters {
    bool       printHelp{false};              // Print help + version information and exit.
    bool       printVersion{false};           // Print version information and exit.
    wstring    imageFileName;                 // Input image cube file name
    bool       printFileInfo{false};          // Print information about the image cube file.
    wstring    outputFileName;                // Output image file name
    FileFormat fileFormat{FileFormat::None};  // Output file format
    int        sliceStart{0};                 // First slice to output
    int        sliceEnd{-1};                  // Last output slice. -1 indicates last slice
    int        sliceStep{1};                  // Step size between slices
};

enum class OptionType {
    Help,
    Version,
    ImageFileName,
    Query,
    OutputFileName,
    Format,
    Slice,

    Unrecognized
};

struct OptionInfo {
    // A description of a single command-line option.

    OptionType type;
    wchar_t    singleLetter;  // Single dash letter
    wstring    longName;      // Double dash string
    bool       takesValue;    // If true, takes option value
};

namespace {
    vector<OptionInfo> optionInfo = {
        {OptionType::Unrecognized,   0,    L"",        false},
        {OptionType::Help,           L'h', L"help",    false},
        {OptionType::Version,        L'v', L"version", false},
        {OptionType::ImageFileName,  L'i', L"input",   true},
        {OptionType::ImageFileName,  L'i', L"image",   true},
        {OptionType::Query,          L'q', L"query",   false},
        {OptionType::OutputFileName, L'o', L"output",  true},
        {OptionType::Format,         L'f', L"format",  true},
        {OptionType::Slice,          L's', L"slice",   true},
    };
}

//__________________________________________________________________________________________________

const OptionInfo& getOptionInfo(wchar_t *arg) {
    // Given a command-line option, return the corresponding OptionInfo structure.

    if (arg[0] == L'/' && arg[1] == L'?')
        return optionInfo[1];

    if (arg[0] != L'-')
        return optionInfo[0];

    if (arg[1] == L'-') {
        for (const auto& option : optionInfo)
            if (_wcsicmp(option.longName.c_str(), arg + 2) == 0)
                return option;
    }

    for (const auto& option : optionInfo)
        if (option.singleLetter == arg[1])
            return option;

    return optionInfo[0];
}

//__________________________________________________________________________________________________

std::pair<wchar_t*, int> scanInteger (wchar_t* str) {
    // Reads the integer from the string. Returns a pair containing the pointer to the remainder of
    // the string, and the integer value.

    auto *ptr = str;
    bool negate = *ptr == L'-';
    if (negate) ++ptr;

    int value = 0;
    for (; isdigit(*ptr);  ++ptr)
        value = (10 * value) + (*ptr - L'0');

    return { ptr, negate ? -value : value };
}

//__________________________________________________________________________________________________

bool parseOptionFormat(Parameters& params, wchar_t* value) {
    // Parse the --format option string. Format is 'ppm', 'ppm:ascii', or 'ppm:binary'.

    for (const auto& format : formatInfo) {
        if (_wcsicmp(format.name.c_str(), value) == 0) {
            params.fileFormat = format.format;
            return true;
        }
    }

    wcerr << "image4: Invalid output file format (" << value << ").\n";
    return false;
}

//__________________________________________________________________________________________________

bool parseOptionSlice (Parameters &params, wchar_t* value) {
    // Parse the --slice option string. Format is '<start>[-<end>][x<stepSize>]'.

    const auto optionValue = value;

    if (!isdigit(*value)) {
        wcerr << "image4: Invalid slice start (" << optionValue << ").\n";
        return false;
    }

    std::tie(value, params.sliceStart) = scanInteger(value);

    if (*value == '-') {
        ++value;
        if (!isdigit(*value)) {
            wcerr << "image4: Invalid slice end (" << optionValue << ").\n";
            return false;
        }
        std::tie(value, params.sliceEnd) = scanInteger(value);
    }

    if (*value == 'x') {
        ++value;
        if (!isdigit(*value)) {
            wcerr << "image4: Invalid slice step (" << optionValue << ").\n";
            return false;
        }
        std::tie(value, params.sliceStep) = scanInteger(value);
    }

    if (*value) {
        wcerr << "image4: Invalid slice option value (" << optionValue << ").\n";
        return false;
    }

    return true;
}

//__________________________________________________________________________________________________

bool processParameters (Parameters &params, int argc, wchar_t *argv[]) {
    // Process the command-line options and load results into the given Parameters object. Returns
    // true on success, false on error.

    if (argc == 1) {
        params.printHelp = true;
        return true;
    }

    for (auto argi = 1;  argi < argc;  ++argi) {
        auto *arg = argv[argi];
        auto optionInfo = getOptionInfo(arg);
        wchar_t *optionValue = nullptr;

        if (optionInfo.takesValue) {
            if (arg[1] != '-' && arg[2] != 0) {  // Single letter option joined with argument value.
                optionValue = arg + 2;
            } else {
                // Option value is next argument.
                if ((argi + 1) == argc) {
                    wcerr << "image4: Missing argument for (" << arg << ").\n";
                    return false;
                }
                optionValue = argv[++argi];
            }
        }

        if (optionInfo.type == OptionType::Unrecognized) {
            wcerr << "image4: Unrecognized command argument: (" << arg << ").\n";
            return false;
        }

        switch (optionInfo.type) {
            default:
            case OptionType::Unrecognized:
                wcerr << "image4: Unrecognized command argument: (" << arg << ").\n";
                return false;

            case OptionType::Help:
                params.printHelp = true;
                break;

            case OptionType::Version:
                params.printVersion = true;
                break;

            case OptionType::ImageFileName:
                params.imageFileName = optionValue;
                break;

            case OptionType::Query:
                params.printFileInfo = true;
                break;

            case OptionType::OutputFileName:
                params.outputFileName = optionValue;
                break;

            case OptionType::Format:
                if (!parseOptionFormat(params, optionValue))
                    return false;
                break;

            case OptionType::Slice:
                if (!parseOptionSlice(params, optionValue))
                    return false;
                break;
        }
    }

    // Validate parameters

    if (params.printHelp || params.printVersion)
        return true;

    if (params.imageFileName.empty()) {
        wcerr << "image4: Missing input image file name.\n";
        return false;
    }

    if (!params.printFileInfo && params.outputFileName.empty()) {
        wcerr << "image4: Expected --query or --output.\n";
        return false;
    }

    if (!params.outputFileName.empty()) {
        if (params.sliceStart < 0) {
            wcerr << "image4: Invalid slice start (" << params.sliceStart << ").\n";
            return false;
        }

        if (params.sliceStep < 1) {
            wcerr << "image4: Invalid slice step (" << params.sliceStep << ").\n";
            return false;
        }

        // If the output file format is not specified, infer it from the file extension.
        if (params.fileFormat == FileFormat::None) {
            for (const auto& format : formatInfo) {
                if (format.format == FileFormat::None)
                    continue;

                auto extension = format.fileExtension.c_str();
                auto* eptr = params.outputFileName.c_str() + params.outputFileName.length() - wcslen(extension);
                if (_wcsicmp(eptr, extension) == 0) {
                    params.fileFormat = format.format;
                    break;
                }
            }

            if (params.fileFormat == FileFormat::None) {
                wcerr << "image4: Unable to determine output file format from file extension ("
                      << params.outputFileName << ").\n";
                return false;
            }
        }
    }

    return true;
}

//__________________________________________________________________________________________________

ifstream openImageFile(const wstring& fileName) {
    // Opens the input image file for reading.

    ifstream imageFile;
    imageFile.open(fileName, ios::binary | ios::in);
    return imageFile;
}

//__________________________________________________________________________________________________

uint32_t readUInt32(ifstream &is) {
    uint8_t b[4];
    is.read(reinterpret_cast<char*>(b), sizeof(b));
    return (static_cast<uint32_t>(b[0]) << 24) | (b[1] << 16) | (b[2] << 8) | b[3];
}

//__________________________________________________________________________________________________

uint16_t readUInt16(ifstream &is) {
    uint8_t b[2];
    is.read(reinterpret_cast<char*>(b), sizeof(b));
    return (static_cast<uint16_t>(b[0]) << 8) | b[1];
}

//__________________________________________________________________________________________________

uint8_t readUInt8(ifstream &is) {
    char b;
    is.read(&b, 1);
    return static_cast<uint8_t>(b);
}

//__________________________________________________________________________________________________

ImageHeader readImageHeader(ifstream &imageFile, wstring imageFileName) {
    // Reads in and returns the 3D image cube header structure. On failure, the magic field is set
    // to zero.

    ImageHeader header;

    header.magic = readUInt32(imageFile);
    if (header.magic != ray4FormatMagic) {
        wcerr << "image4: Image file \"" << imageFileName << "\" is not a value ray4 image file.\n";
        return { 0 };
    }

    header.version = readUInt8(imageFile);
    if (header.version != 1) {
        wcerr << "image4: ray4 image file \"" << imageFileName << "\" is an unsupported version ("
              << header.version << ").\n";
        return { 0 };
    }

    header.bitsPerPixel = readUInt8(imageFile);
    if (header.bitsPerPixel != 24) {
        wcerr << "image4: ray4 image file \"" << imageFileName << "\" has an unsupported bits per pixel ("
            << header.bitsPerPixel << ").\n";
        return { 0 };
    }

    for (auto i = 0;  i < 3;  ++i)
        header.aspect[i] = readUInt16(imageFile);

    if (header.aspect[0] != 1 || header.aspect[1] != 1 || header.aspect[2] != 1) {
        wcerr << "image4: ray4 image file \"" << imageFileName << "\" has aspect ratio "
              << header.aspect[0] << ':' << header.aspect[1] << ':' << header.aspect[2]
              << ". Only 1:1:1 is supported.\n";
        return { 0 };
    }

    for (auto i = 0;  i < 3;  ++i)
        header.start[i] = readUInt16(imageFile);

    for (auto i = 0;  i < 3;  ++i)
        header.end[i] = readUInt16(imageFile);

    if (header.end[0] < header.start[0] || header.end[1] < header.start[1] || header.end[2] < header.start[2]) {
        wcerr << "image4: ray4 image file \"" << imageFileName << "\" has invalid start/end values.\n";
        return { 0 };
    }

    return header;
}

//__________________________________________________________________________________________________

bool generateImageSlices(ifstream& imageFile, const ImageHeader& header, const Parameters& params) {
    // Generate the image slices requested by the user.
    // For now, just generate a single image slice and save it out.

    if (params.fileFormat != FileFormat::PPM_ASCII) {
        wcerr << "image4: Only ASCII PPM output format is supported at this time.\n";
        return false;
    }

    // Calculate image dimensions and allocate the plane pixel buffer.

    int resolution[3] = {
        1 + header.end[0] - header.start[0],
        1 + header.end[1] - header.start[1],
        1 + header.end[2] - header.start[2]
    };

    const int bytesPerPixel  = header.bitsPerPixel / 8;
    const int pixelsPerPlane = resolution[0] * resolution[1];
    const int bytesPerPlane  = pixelsPerPlane * bytesPerPixel;

    auto planeBuff = new char[bytesPerPlane];

    // Open the output file.

    ofstream outputImage;
    outputImage.open(params.outputFileName, ios::binary | ios::out);
    if (!outputImage.good()) {
        wcerr << "image4: Open failed for output image file \"" << params.outputFileName << "\".\n";
        return false;
    }

    // Seek to the start plane.

    int firstPlaneOffset = sizeof(ImageHeader) + (params.sliceStart * bytesPerPlane);
    imageFile.seekg(firstPlaneOffset);

    // Read the image plane.

    imageFile.read(planeBuff, bytesPerPlane);

    // Write the image plane to the ASCII PPM output file.

    // ASCII PPM header
    outputImage << "P3\n" << resolution[0] << ' ' << resolution[1] << '\n' << "255\n";
    
    outputImage << setfill(' ') << setw(3);

    uint8_t *color = reinterpret_cast<uint8_t*>(planeBuff);

    for (auto i = 0; i < pixelsPerPlane; ++i) {
        outputImage << setfill(' ') << setw(3)
                    << to_string(*color++) << ' ' << to_string(*color++) << ' ' << to_string(*color++) << '\n';
    }

    outputImage.close();

    return true;
}

//__________________________________________________________________________________________________

void printFileInfo(const ImageHeader& header, const wstring& imageFileName) {
    // Print information about the image file.

    wcout << "\nray4 image file \"" << imageFileName << "\":\n";
    wcout << "    Format Version: " << header.version << '\n';
    wcout << "    Bits Per Pixel: " << header.bitsPerPixel << '\n';
    wcout << "    Aspect Ratio: " << header.aspect[0] << ':' << header.aspect[1] << ':' << header.aspect[2] << '\n';
    wcout << "    Start Pixel: " << header.start[0] << ',' << header.start[1] << ',' << header.start[2] << '\n';
    wcout << "    End Pixel: " << header.end[0] << ',' << header.end[1] << ',' << header.end[2] << '\n';
    wcout << "    Effective Resolution: "
          << (1 + header.end[0] - header.start[0]) << 'x'
          << (1 + header.end[1] - header.start[1]) << 'x'
          << (1 + header.end[2] - header.start[2]) << '\n';
    wcout << '\n';
}

//__________________________________________________________________________________________________

int wmain(int argc, wchar_t *argv[]) {
    Parameters params;

    if (!processParameters(params, argc, argv))
        return 1;

    if (params.printHelp)
        wcout << usage;

    if (params.printHelp || params.printVersion) {
        wcout << version;
        return 0;
    }

    ifstream imageStream = openImageFile(params.imageFileName);

    if (!imageStream.good()) {
        wcerr << "image4: Open failed for image file \"" << params.imageFileName << "\".\n";
        return 1;
    }

    ImageHeader imageHeader = readImageHeader(imageStream, params.imageFileName);

    if (!imageHeader.magic)
        return 1;

    if (params.printFileInfo) {
        printFileInfo(imageHeader, params.imageFileName);
        return 0;
    }

    if (!params.outputFileName.empty() && !generateImageSlices(imageStream, imageHeader, params))
        return 1;

    return 0;
}
